# ğŸ”§ ç…§ç‰‡ä¸Šå‚³åŠŸèƒ½ - æŠ€è¡“å¯¦ä½œæ–‡æª”

## ğŸ“Š ç³»çµ±æ¶æ§‹æ¦‚è¦½

```mermaid
graph TD
    A[ç”¨æˆ¶ç€è¦½å™¨] --> B[ChatView.vue]
    B --> C[chat.js Store]
    C --> D[API Layer]
    D --> E[Flask Backend]
    E --> F[Gemini Vision API]
    E --> G[SQLite Database]
    
    subgraph "å‰ç«¯å±¤"
        B --> B1[æª”æ¡ˆé¸æ“‡å™¨]
        B --> B2[åœ–ç‰‡é è¦½]
        B --> B3[æ‹–æ”¾ä¸Šå‚³]
    end
    
    subgraph "å¾Œç«¯å±¤"
        E --> E1[æª”æ¡ˆé©—è­‰]
        E --> E2[Base64 ç·¨ç¢¼]
        E --> E3[API å‘¼å«]
    end
```

## ğŸ—‚ï¸ ç¨‹å¼ç¢¼æª”æ¡ˆè©³ç´°èªªæ˜

### å‰ç«¯æª”æ¡ˆ (Frontend)

#### 1. `/frontend/src/views/ChatView.vue`
**åŠŸèƒ½**ï¼šä¸»è¦çš„èŠå¤©ç•Œé¢çµ„ä»¶ï¼ŒåŒ…å«ç…§ç‰‡ä¸Šå‚³åŠŸèƒ½

**é—œéµä»£ç¢¼å€æ®µ**ï¼š
```vue
<!-- ç…§ç‰‡ä¸Šå‚³æŒ‰éˆ• -->
<el-button
  type="info"
  :icon="Picture"
  @click="openFileSelector"
  :disabled="chatStore.isLoading"
  title="ä¸Šå‚³å±±ç¾Šç…§ç‰‡"
>
  ä¸Šå‚³ç…§ç‰‡
</el-button>

<!-- éš±è—çš„æª”æ¡ˆè¼¸å…¥å…ƒç´  -->
<input
  ref="fileInputRef"
  type="file"
  accept="image/*"
  @change="handleImageSelect"
  style="display: none;"
/>
```

**ä¸»è¦æ–¹æ³•**ï¼š
- `openFileSelector()`: é–‹å•Ÿæª”æ¡ˆé¸æ“‡å™¨
- `handleImageSelect(event)`: è™•ç†æª”æ¡ˆé¸æ“‡äº‹ä»¶
- `removeSelectedImage()`: ç§»é™¤é¸ä¸­çš„åœ–ç‰‡
- `handleSendMessage()`: ç™¼é€è¨Šæ¯ï¼ˆåŒ…å«åœ–ç‰‡ï¼‰

**è³‡æ–™çµæ§‹**ï¼š
```javascript
const selectedImage = ref({
  file: File,           // åŸå§‹æª”æ¡ˆå°è±¡
  url: String,          // Data URL ç”¨æ–¼é è¦½
  name: String,         // æª”æ¡ˆåç¨±
  size: Number,         // æª”æ¡ˆå¤§å°
  type: String          // MIME é¡å‹
});
```

#### 2. `/frontend/src/stores/chat.js`
**åŠŸèƒ½**ï¼šèŠå¤©ç‹€æ…‹ç®¡ç†ï¼Œè™•ç†è¨Šæ¯å’Œåœ–ç‰‡è³‡æ–™

**é—œéµæ–¹æ³•**ï¼š
```javascript
async function sendMessage(apiKey, userMessage, earNumContext, imageData = null) {
  // æº–å‚™ç”¨æˆ¶è¨Šæ¯ç‰©ä»¶
  const userMessageObj = { 
    role: 'user', 
    content: userMessage || (imageData ? 'è«‹å¹«æˆ‘åˆ†æé€™å¼µå±±ç¾Šç…§ç‰‡' : '')
  };
  
  // å¦‚æœæœ‰åœ–ç‰‡ï¼Œæ·»åŠ åœ–ç‰‡è³‡è¨Š
  if (imageData) {
    userMessageObj.image = {
      url: imageData.url,
      name: imageData.name,
      type: imageData.type
    };
  }
  
  // å‘¼å« API
  const response = await api.chatWithAgent(
    apiKey, userMessage, sessionId.value, earNumContext, imageData
  );
}
```

#### 3. `/frontend/src/api/index.js`
**åŠŸèƒ½**ï¼šAPI å‘¼å«å±¤ï¼Œè™•ç† HTTP è«‹æ±‚

**é—œéµæ–¹æ³•**ï¼š
```javascript
chatWithAgent(apiKey, message, sessionId, earNumContext, imageData = null, errorHandler) {
  // å¦‚æœæœ‰åœ–ç‰‡ï¼Œä½¿ç”¨ FormData
  if (imageData && imageData.file) {
    const formData = new FormData();
    formData.append('api_key', apiKey);
    formData.append('message', message);
    formData.append('session_id', sessionId);
    if (earNumContext) formData.append('ear_num_context', earNumContext);
    formData.append('image', imageData.file);
    
    return withErrorHandling(() => 
      apiClient.post('/api/agent/chat', formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      }), errorHandler);
  } else {
    // ç´”æ–‡å­—è«‹æ±‚
    const payload = { api_key: apiKey, message, session_id: sessionId, ear_num_context: earNumContext };
    return withErrorHandling(() => apiClient.post('/api/agent/chat', payload), errorHandler);
  }
}
```

### å¾Œç«¯æª”æ¡ˆ (Backend)

#### 1. `/backend/app/api/agent.py`
**åŠŸèƒ½**ï¼šä¸»è¦çš„ API ç«¯é»ï¼Œè™•ç†èŠå¤©å’Œåœ–ç‰‡åˆ†æ

**é—œéµè·¯ç”±**ï¼š
```python
@bp.route('/chat', methods=['POST'])
@login_required
def chat_with_agent():
    """èˆ‡ AI èŠå¤©ï¼Œæ”¯æ´æ–‡å­—å’Œåœ–ç‰‡"""
```

**åœ–ç‰‡è™•ç†æµç¨‹**ï¼š
```python
# 1. æª¢æŸ¥è«‹æ±‚é¡å‹
if 'image' in request.files:
    # è™•ç†åŒ…å«åœ–ç‰‡çš„è«‹æ±‚
    image_file = request.files['image']
    
    # 2. æª”æ¡ˆé©—è­‰
    allowed_types = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp']
    if image_file.content_type not in allowed_types:
        return jsonify(error="ä¸æ”¯æ´çš„åœ–ç‰‡æ ¼å¼"), 400
    
    # 3. å¤§å°æª¢æŸ¥
    image_data = image_file.read()
    if len(image_data) > 10 * 1024 * 1024:  # 10MB
        return jsonify(error="åœ–ç‰‡æª”æ¡ˆä¸èƒ½è¶…é 10MB"), 400
    
    # 4. Base64 ç·¨ç¢¼
    image_base64 = base64.b64encode(image_data).decode('utf-8')
```

**Gemini API æ•´åˆ**ï¼š
```python
# æº–å‚™åŒ…å«åœ–ç‰‡çš„è¨Šæ¯
user_message_parts = [{"text": current_user_message_with_context}]
if image_base64:
    user_message_parts.append({
        "inline_data": {
            "mime_type": mime_type,
            "data": image_base64
        }
    })

chat_messages_for_api.append({"role": "user", "parts": user_message_parts})
```

#### 2. `/backend/app/utils.py`
**åŠŸèƒ½**ï¼šå·¥å…·å‡½æ•¸ï¼ŒåŒ…å« Gemini API å‘¼å«

**é—œéµå‡½æ•¸**ï¼š
```python
def call_gemini_api(prompt_text, api_key, generation_config_override=None, safety_settings_override=None):
    """
    é€šç”¨ Gemini API èª¿ç”¨å‡½æ•¸ï¼Œæ”¯æ´æ–‡å­—å’Œåœ–ç‰‡
    """
    # è™•ç†å¤šç¨®è¼¸å…¥æ ¼å¼
    payload_contents = []
    if isinstance(prompt_text, str):
        payload_contents.append({"role": "user", "parts": [{"text": prompt_text}]})
    elif isinstance(prompt_text, list):
        payload_contents = prompt_text  # å·²ç¶“æ ¼å¼åŒ–çš„è¨Šæ¯é™£åˆ—

def encode_image_to_base64(image_data):
    """
    å°‡åœ–ç‰‡æ•¸æ“šç·¨ç¢¼ç‚º base64 å­—ç¬¦ä¸²
    """
    return base64.b64encode(image_data).decode('utf-8')
```

#### 3. `/backend/app/models.py`
**åŠŸèƒ½**ï¼šè³‡æ–™åº«æ¨¡å‹å®šç¾©

**èŠå¤©è¨˜éŒ„æ¨¡å‹**ï¼š
```python
class ChatHistory(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    session_id = db.Column(db.String(100), nullable=False)
    role = db.Column(db.String(20), nullable=False)  # 'user' æˆ– 'model'
    content = db.Column(db.Text, nullable=False)     # åŒ…å« "[åŒ…å«åœ–ç‰‡]" æ¨™è¨˜
    ear_num_context = db.Column(db.String(50))
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
```

#### 4. `/backend/app/schemas.py`
**åŠŸèƒ½**ï¼šè«‹æ±‚è³‡æ–™é©—è­‰

**èŠå¤©è«‹æ±‚æ¨¡å‹**ï¼š
```python
class AgentChatModel(BaseModel):
    api_key: str
    message: str
    session_id: str
    ear_num_context: Optional[str] = None
    
    class Config:
        str_strip_whitespace = True
```

## ğŸ”„ è³‡æ–™æµç¨‹

### 1. åœ–ç‰‡ä¸Šå‚³æµç¨‹
```mermaid
sequenceDiagram
    participant U as ç”¨æˆ¶
    participant C as ChatView
    participant S as Store
    participant A as API
    participant B as Backend
    participant G as Gemini

    U->>C: é»æ“Šä¸Šå‚³æŒ‰éˆ•
    C->>C: é–‹å•Ÿæª”æ¡ˆé¸æ“‡å™¨
    U->>C: é¸æ“‡åœ–ç‰‡æª”æ¡ˆ
    C->>C: é©—è­‰æª”æ¡ˆæ ¼å¼å’Œå¤§å°
    C->>C: å‰µå»ºé è¦½ URL
    C->>S: å„²å­˜åœ–ç‰‡è³‡æ–™
    U->>C: é»æ“Šç™¼é€
    S->>A: å‘¼å« chatWithAgent
    A->>B: POST /api/agent/chat (FormData)
    B->>B: æª”æ¡ˆé©—è­‰å’Œ Base64 ç·¨ç¢¼
    B->>G: å‘¼å« Gemini Vision API
    G->>B: è¿”å›åˆ†æçµæœ
    B->>A: è¿”å› HTML æ ¼å¼å›è¦†
    A->>S: æ›´æ–°èŠå¤©è¨˜éŒ„
    S->>C: æ›´æ–° UI é¡¯ç¤º
```

### 2. éŒ¯èª¤è™•ç†æµç¨‹
```mermaid
flowchart TD
    A[æª”æ¡ˆé¸æ“‡] --> B{æª”æ¡ˆé©—è­‰}
    B -->|æ ¼å¼éŒ¯èª¤| C[é¡¯ç¤ºæ ¼å¼éŒ¯èª¤è¨Šæ¯]
    B -->|å¤§å°è¶…é™| D[é¡¯ç¤ºå¤§å°éŒ¯èª¤è¨Šæ¯]
    B -->|é©—è­‰é€šé| E[ä¸Šå‚³åˆ°å¾Œç«¯]
    E --> F{å¾Œç«¯é©—è­‰}
    F -->|é©—è­‰å¤±æ•—| G[è¿”å› 400 éŒ¯èª¤]
    F -->|é©—è­‰é€šé| H[å‘¼å« Gemini API]
    H --> I{API å›æ‡‰}
    I -->|æˆåŠŸ| J[è¿”å›åˆ†æçµæœ]
    I -->|å¤±æ•—| K[è¿”å› 500 éŒ¯èª¤]
```

## ğŸ› ï¸ é–‹ç™¼ç’°å¢ƒè¨­å®š

### å‰ç«¯è¨­å®š
```bash
cd frontend
npm install
npm run dev
```

**é—œéµä¾è³´**ï¼š
- `vue@^3.4.0`
- `element-plus@^2.4.0`
- `@element-plus/icons-vue@^2.3.0`
- `pinia@^2.1.0`
- `axios@^1.6.0`

### å¾Œç«¯è¨­å®š
```bash
cd backend
pip install -r requirements.txt
export GOOGLE_API_KEY=your_gemini_api_key
python run.py
```

**é—œéµä¾è³´**ï¼š
- `Flask==2.3.3`
- `Flask-Login==0.6.3`
- `SQLAlchemy==2.0.21`
- `Pydantic==2.4.2`
- `requests==2.31.0`

## ğŸ§ª æ¸¬è©¦ç­–ç•¥

### å–®å…ƒæ¸¬è©¦
```javascript
// frontend/src/stores/chat.test.js
describe('Chat Store - Image Upload', () => {
  test('should handle image data correctly', () => {
    const imageData = {
      file: new File(['test'], 'test.jpg', { type: 'image/jpeg' }),
      url: 'data:image/jpeg;base64,...',
      name: 'test.jpg',
      size: 1024,
      type: 'image/jpeg'
    };
    
    // æ¸¬è©¦ sendMessage æ–¹æ³•
    expect(sendMessage('api_key', 'test message', null, imageData)).toBeDefined();
  });
});
```

### æ•´åˆæ¸¬è©¦
```python
# test_image_upload.py
def test_image_upload_api():
    """æ¸¬è©¦åœ–ç‰‡ä¸Šå‚³ API ç«¯é»"""
    with open('test_image.jpg', 'rb') as f:
        response = client.post('/api/agent/chat', data={
            'api_key': 'test_key',
            'message': 'Analyze this image',
            'session_id': 'test_session',
            'image': (f, 'test.jpg')
        })
    assert response.status_code == 200
```

## ğŸ” åµéŒ¯æŒ‡å—

### å‰ç«¯åµéŒ¯
```javascript
// åœ¨ ChatView.vue ä¸­æ·»åŠ æ—¥èªŒ
const handleImageSelect = (event) => {
  console.log('Selected file:', event.target.files[0]);
  // ... è™•ç†é‚è¼¯
};
```

### å¾Œç«¯åµéŒ¯
```python
# åœ¨ agent.py ä¸­æ·»åŠ æ—¥èªŒ
current_app.logger.info(f"Received image: {image_file.filename}, size: {len(image_data)}")
```

### å¸¸è¦‹å•é¡Œæ’æŸ¥

1. **CORS éŒ¯èª¤**
   - æª¢æŸ¥ Flask CORS è¨­å®š
   - ç¢ºèªè«‹æ±‚æ¨™é ­æ­£ç¢º

2. **æª”æ¡ˆä¸Šå‚³å¤±æ•—**
   - æª¢æŸ¥ Content-Type æ˜¯å¦ç‚º multipart/form-data
   - ç¢ºèªæª”æ¡ˆå¤§å°é™åˆ¶

3. **API é‡‘é‘°éŒ¯èª¤**
   - é©—è­‰ Gemini API é‡‘é‘°æœ‰æ•ˆæ€§
   - æª¢æŸ¥ç’°å¢ƒè®Šæ•¸è¨­å®š

## ğŸ“ˆ æ•ˆèƒ½æœ€ä½³åŒ–

### å‰ç«¯å„ªåŒ–
```javascript
// åœ–ç‰‡å£“ç¸®
const compressImage = (file, maxSize = 1024 * 1024) => {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = () => {
      // è¨ˆç®—å£“ç¸®æ¯”ä¾‹
      const ratio = Math.min(800 / img.width, 800 / img.height);
      canvas.width = img.width * ratio;
      canvas.height = img.height * ratio;
      
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      canvas.toBlob(resolve, 'image/jpeg', 0.8);
    };
    
    img.src = URL.createObjectURL(file);
  });
};
```

### å¾Œç«¯å„ªåŒ–
```python
# éåŒæ­¥è™•ç†
import asyncio
from concurrent.futures import ThreadPoolExecutor

async def process_image_async(image_data, api_key):
    loop = asyncio.get_event_loop()
    with ThreadPoolExecutor() as executor:
        result = await loop.run_in_executor(
            executor, call_gemini_api, image_data, api_key
        )
    return result
```

## ğŸš€ éƒ¨ç½²æ³¨æ„äº‹é …

### ç’°å¢ƒè®Šæ•¸
```bash
# .env æª”æ¡ˆ
GOOGLE_API_KEY=your_gemini_api_key_here
MAX_CONTENT_LENGTH=10485760  # 10MB
UPLOAD_FOLDER=/tmp/uploads
```

### Docker é…ç½®
```dockerfile
# å¾Œç«¯ Dockerfile ç‰‡æ®µ
RUN mkdir -p /tmp/uploads && \
    chmod 755 /tmp/uploads

ENV MAX_CONTENT_LENGTH=10485760
```

### Nginx è¨­å®š
```nginx
# å¢åŠ æª”æ¡ˆä¸Šå‚³å¤§å°é™åˆ¶
client_max_body_size 10M;

# ä»£ç†è¨­å®š
location /api/agent/chat {
    proxy_pass http://backend:5000;
    proxy_set_header Content-Type $content_type;
}
```

---

*æŠ€è¡“æ–‡æª”ç‰ˆæœ¬ï¼šv1.0.0*  
*æœ€å¾Œæ›´æ–°ï¼š2025å¹´8æœˆ1æ—¥*
